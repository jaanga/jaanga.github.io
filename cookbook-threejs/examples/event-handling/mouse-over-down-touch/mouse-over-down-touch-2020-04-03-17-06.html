<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0">
<meta name=description
	content="Real-time interactive 3D graphics in your browser using the WebGL and the Three.js JavaScript library">
<meta name=keywords content="Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM">
<meta name=version content="2020-04-03">


<title></title>

<style>

/* Copyright 2020 Theo Armour. MIT License */

:root { font: 100% monospace; }

* { box-sizing: border-box; }

body { margin: 0; overflow: hidden; }

a { color: crimson; text-decoration: none; }
a:hover, a:focus, a:active { background-color: yellow; color: #aaa; text-decoration: underline; }

button { background-color: #ddd; border: none; border-radius: 2px; color: #322;cursor: pointer; padding: 3px 5px; }
button:hover { background: #ccc; color: #fff }

input[ type=range ] { -webkit-appearance: none; -moz-appearance: none; background-color: #ddd; border-radius: 2px; height: 1.7ch; width: 100%; }
input[ type=range ]::-moz-range-thumb { background-color: #888; border-radius: 2; width: 10px; }
input[ type=range ]::-webkit-slider-thumb { -webkit-appearance: none; background-color: #888; height: 18px; width: 10px; }

.help { float: right; }

.couponcode { float: right }

.couponcode:hover>.coupontooltip { display: block; }

.coupontooltip { border: 0.8ch double #888; background: white; display: none;
	font: 100% monospace; font-size: 1rem; font-weight: normal; /* unset summary settings */
	margin-left: -20ch; padding: 10px; position: absolute; z-index: 1000; }

#navMenu { margin: 0 20px; max-width: 15rem; position: absolute; }


#DMTdivParent {
	border: 1px solid#444;
	border-radius: 1rem;
	box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.9), 0 6px 20px 0 rgba(0, 0, 0, 0.6);
	height: 20ch;
	overflow: hidden;
	position: absolute;
	left: 50%;
	resize: both;
	top: 50%;
	//transform: translate(-50% , -50%);
	width: 20ch;
}

#DMTdivHeader {
	background-color: #ccc;
	cursor: move;
	padding: 1ch;
	user-select: none;
}

#DMTdivContainer {
	background-color: white;
	height: 98%;
	overflow: auto;
	padding: 1ch;
}

#divMouseDown { border: 1px solid lightblue; background: pink; padding: 1ch; position: absolute; width: 15ch; z-index: 10}


</style>

</head>

<body>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r114/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r114/examples/js/controls/OrbitControls.js"></script>

<nav id="navMenu">

	<header id="hdrTitle">

		<h2>
			<a id=aSource target=_top title="Source code on GitHub" >
				<img id=imgIcon height=18 style=opacity:0.5; >
			</a>

			<a href="" title="Click to reload this page" >
				<span id=sTitle ></span>
				<span id=sVersion ></span>
			</a>

			<span class="couponcode" >??<span id=divDescription class="coupontooltip" ></span></span>

		</h2>

	</header>

	<p>
		<button onclick="addMeshes()">add meshes</button>
	</p>


	<p>
		<button onclick=controls.reset() >reset view</button>
		<button onclick="sceneRotation = sceneRotation === 1 ? 0 : 1;">rotation</button>
	</p>

	<p>
		<output id=outSpeed>50</output>
		<input type="range" id="inpSpeed" onclick="sceneRotation=0.05 * this.value;outSpeed.innerHTML=this.value;" />
	</p>

	<div id="divLog"></div>

</nav>



<div id=DMTdivParent>

	<div id=DMTdivHeader>
		Drag me
		<span onclick=DMTdivParent.hidden=true; style=float:right>[ x ]</span>
	</div>

	<div id=DMTdivContainer >

		<div id=DMTdivContent>
			lorem ipsum, quia dolor sit, amet, consectetur, adipisci velit, sed quia non numquam eius
			modi tempora incidunt, ut labore et dolore magnam aliquam quaerat voluptatem. ut enim ad minima veniam, quis
			nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? quis
			autem vel eum iure reprehenderit, qui in ea voluptate velit esse, quam nihil molestiae consequatur, vel
			illum, qui dolorem eum fugiat, quo voluptas nulla pariatur?
		</div>

	</div>

</div>

<script>

let intersected;

aSource.href = "https://github.com/zzzzz/xxxxx.html";
imgIcon.src = "https://pushme-pullyou.github.io/github-mark-32.png";

sTitle.innerHTML= document.title ? document.title : location.href.split( '/' ).pop().slice( 0, - 5 ).replace( /-/g, ' ' );
const version = document.head.querySelector( "[ name=version ]" );
sVersion.innerHTML = version ? version.content : "";
divDescription.innerHTML = document.head.querySelector( "[ name=description ]" ).content;


let mesh, group, axesHelper, lightDirectional, cameraHelper;
let sceneRotation = 1;
let renderer, camera, controls, scene;




function init() {

	camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.set( - 100, - 100, 100 );
	camera.up.set( 0, 0, 1 );

	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0xcce0ff );
	//scene.fog = new THREE.Fog( 0xcce0ff, 550, 800 );
	scene.add( camera )

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
	renderer.outputEncoding = THREE.sRGBEncoding;
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;

	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.maxDistance = 500;
	//controls.rotateSpeed = 2;
	controls.autoRotate = true;

	//controls.maxPolarAngle = Math.PI * 0.5;


	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'orientationchange', onWindowResize, false );
	window.addEventListener( 'keyup', () => sceneRotation = 0, false );
	renderer.domElement.addEventListener( 'click', () => sceneRotation = 0, false );

	addLights();

	axesHelper = new THREE.AxesHelper( 100 );
	scene.add( axesHelper );

	addGround();

	//addMesh();

	addMeshes();

	zoomObjectBoundingSphere();



	window.addEventListener( 'keydown', onStart );

	renderer.domElement.addEventListener( 'mousedown', onStart );
	//renderer.domElement.addEventListener( 'mousemove', onStart );
	renderer.domElement.addEventListener( 'wheel', onStart );

	renderer.domElement.addEventListener( 'touchstart', onStart );
	renderer.domElement.addEventListener( 'touchmove', onStart );
	renderer.domElement.addEventListener( 'touchend', onStart );

	DMTdivContent.innerHTML = `<b> vvvv ~ ${ version.content }</b>`;

}

function onStart () {

	controls.autoRotate = false;

	window.removeEventListener( 'keydown', onStart );

	renderer.domElement.removeEventListener( 'mousedown', onStart );
	//renderer.domElement.removeEventListener( 'mousemove', onStart );
	renderer.domElement.removeEventListener( 'wheel', onStart );

	renderer.domElement.removeEventListener( 'touchstart', onStart );
	renderer.domElement.removeEventListener( 'touchmove', onStart );
	renderer.domElement.removeEventListener( 'touchend', onStart );

	DMT.init();

};

// https://redstapler.co/4-ways-to-center-div-css/




const DMT = {};

DMT.x = 0;
DMT.y = 0;


DMT.init = function () {

	DMTdivParent.hidden = true;

	renderer.domElement.addEventListener( "mouseover", DMT.onEvent );
	renderer.domElement.addEventListener( "touchstart", DMT.onEvent );

	DMT.onEvent(); // for mouse

}


DMT.onEvent = function( e ) {
	//console.log( '', e );

	renderer.domElement.addEventListener( "touchmove", DMT.onMove );
	renderer.domElement.addEventListener( "touchend", DMT.onOut );
	renderer.domElement.addEventListener( 'mousemove', DMT.onMove );
	renderer.domElement.addEventListener( 'mouseout', DMT.onOut );

	DMT.onMove( e ); // for touch

}


DMT.onMove = function( e ) {
	//console.log( 'e move', e );

	if ( e ) { DMT.checkIntersect ( e ); }

}


DMT.onMouseOverOut = function () {

	renderer.domElement.removeEventListener( "touchmove", DMT.onMove );
	renderer.domElement.removeEventListener( "touchend", DMT.onOut );
	renderer.domElement.removeEventListener( 'mousemove', DMT.onMove );
	renderer.domElement.removeEventListener( 'mouseup', DMT.onOut );

};



DMT.checkIntersect = function ( event ) {
	console.log( 'event chkInt ', event );

	if ( event.type === "touchmove" || event.type === "touchstart" ) {

		event.clientX = event.touches[ 0 ].clientX;
		event.clientY = event.touches[ 0 ].clientY;

	}

	const mouse = new THREE.Vector2();
	mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

	const raycaster = new THREE.Raycaster();
	raycaster.setFromCamera( mouse, camera );

	const intersects = raycaster.intersectObjects( group.children );

	if ( intersects.length > 0 ) {

		if ( intersected !== intersects[ 0 ].object ) {

			intersected = intersects[ 0 ].object;
			//console.log( 'int', intersected );

			DMTdivParent.hidden = false;
			DMTdivParent.style.left = event.clientX + "px";
			DMTdivParent.style.top = event.clientY + "px";

			DMTdivContent.innerHTML = `
			<p>${ event.clientX } ${ event.clientY }
			<p>${ intersected.name }`;

		}

	} else {

		intersected = null;
		DMTdivParent.hidden = true;
		DMTdivContent.innerHTML = "";

	}

}



//////////

function addLights() {

	//scene.add( new THREE.AmbientLight( 0x404040 ) );
	scene.add( new THREE.AmbientLight( 0x666666 ) );

	const pointLight = new THREE.PointLight( 0xffffff, 0.2 );
	pointLight.position.copy( camera.position );
	camera.add( pointLight );

	lightDirectional = new THREE.DirectionalLight( 0xdffffff, 0.5 );
	lightDirectional.position.set( -50, -200, 100 );
	lightDirectional.castShadow = true;
	lightDirectional.shadow.mapSize.width = 1024;
	lightDirectional.shadow.mapSize.height = 1024;

	var d = 100;
	lightDirectional.shadow.camera.left = - d;
	lightDirectional.shadow.camera.right = d;
	lightDirectional.shadow.camera.top = d;
	lightDirectional.shadow.camera.bottom = - d;
	lightDirectional.shadow.camera.far = 500;
	scene.add( lightDirectional );

	scene.add( new THREE.CameraHelper( lightDirectional.shadow.camera ) );

}



function addGround() {

	const geometry = new THREE.PlaneBufferGeometry( 2000, 2000 );
	const material = new THREE.MeshPhongMaterial( { color: 0xaaaaaa, depthWrite: false, side: 2 } );
	const mesh = new THREE.Mesh( geometry, material );
	mesh.position.z = -50;
	mesh.receiveShadow = true;
	scene.add( mesh );

}



function zoomObjectBoundingSphere( obj = group ) {
	//console.log( "obj", obj );

	center = new THREE.Vector3( 0, 0, 0 );
	radius=  50;

	const bbox = new THREE.Box3().setFromObject( obj );
	//console.log( 'bbox', bbox );

	if ( bbox.max.x !== Infinity ) {

		const sphere = bbox.getBoundingSphere( new THREE.Sphere() );

		center = sphere.center;
		radius = sphere.radius;
		//console.log( "sphere", sphere )
	}

	controls.target.copy( center ); // needed because model may be far from origin
	controls.maxDistance = 50 * radius;

	delta = camera.position.clone().sub( controls.target ).normalize();
	//console.log( 'delta', delta );

	position = controls.target.clone().add( delta.multiplyScalar( 2 * radius ) );
	//console.log( 'position', position );

	distance = controls.target.distanceTo( camera.position );

	//camera.zoom = distance / (  * radius ) ;

	camera.position.copy( center.clone().add( new THREE.Vector3( -2 * radius, 2 * radius, 1.0 * radius ) ) );
	camera.near = 0.001 * radius; //2 * camera.position.length();
	camera.far = 50 * radius; //2 * camera.position.length();
	camera.updateProjectionMatrix();

	axesHelper.position.copy( center );

	if ( lightDirectional ) {

		lightDirectional.position.copy( center.clone().add( new THREE.Vector3( -1.5 * radius, 1.5 * radius, 1.5 * radius ) ) );
		lightDirectional.shadow.camera.scale.set( 0.02 * radius, 0.02 * radius, 0.2 * radius );

		//targetObject.position.copy( center );

		scene.remove( cameraHelper );
		cameraHelper = new THREE.CameraHelper( lightDirectional.shadow.camera );
		scene.add( cameraHelper );

	}

	let event = new Event( "onresetthree", {"bubbles": true, "cancelable": false, detail: true } );

	//window.addEventListener( "onrresetthree", doThings, false );

	// listening: or-object-rotation-xx.js
	// listening: dss-display-scene-settings-xx.js

	window.dispatchEvent( event );

};



function addMesh( size = 5 ) {

	// CylinderGeometry( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded )
	// SphereGeometry( radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength )
	// TorusGeometry( radius, tube, radialSegments, tubularSegments, arc )

	const geometry = new THREE.BoxGeometry( size, size, size );

	geometry.applyMatrix4( new THREE.Matrix4().makeRotationX( -0.5 * Math.PI ) );
	geometry.applyMatrix4( new THREE.Matrix4().makeScale( 1, 1, 1 ) );
	geometry.applyMatrix4( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	//const material = new THREE.MeshNormalMaterial();
	const material = new THREE.MeshPhongMaterial( { color: 0xffffff * Math.random(), specular: 0xffffff } );
	mesh = new THREE.Mesh( geometry, material );
	mesh.receiveShadow = true;
	mesh.castShadow = true;
	scene.add( mesh );

	return mesh;

}



function addMeshes( count = 100 ) {

	scene.remove( group );

	group = new THREE.Group();

	for ( let i = 0; i < count; i++ ) { group.add( addMesh() ) };

	group.children.forEach( ( mesh, index ) => {
		mesh.position.set( Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50 );
		mesh.rotation.set( 0.2 * Math.random(), 0.2 * Math.random(), 0.2 * Math.random() );
		mesh.name = `mesh: ${ index }`;
	} );

	scene.add( group );

	zoomObjectBoundingSphere( group )

}



function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

	controls.handleResize();

	//console.log( 'onWindowResize  window.innerWidth', window.innerWidth );

}



function animate() {

	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	controls.update();
	//group.rotation.z += sceneRotation / 1000;

}


init();
animate();

</script>
</body>
</html>