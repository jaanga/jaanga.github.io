<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0">
<meta name=description
	content="Real-time interactive 3D graphics in your browser using the WebGL and the Three.js JavaScript library">
<meta name=keywords content="Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM">
<meta name=version content="2020-03-03">


<title></title>

<style>

/* Copyright 2020 Theo Armour. MIT License */

:root { font: 100% monospace; }

* { box-sizing: border-box; }

body { margin: 0; overflow: hidden; }

a { color: crimson; text-decoration: none; }
a:hover, a:focus, a:active { background-color: yellow; color: #aaa; text-decoration: underline; }

button { background-color: #ddd; border: none; border-radius: 2px; color: #322;cursor: pointer; padding: 3px 5px; }
button:hover { background: #ccc; color: #fff }

input[ type=range ] { -webkit-appearance: none; -moz-appearance: none; background-color: #ddd; border-radius: 2px; height: 1.7ch; width: 100%; }
input[ type=range ]::-moz-range-thumb { background-color: #888; border-radius: 2; width: 10px; }
input[ type=range ]::-webkit-slider-thumb { -webkit-appearance: none; background-color: #888; height: 18px; width: 10px; }

.help { float: right; }

.couponcode { float: right }

.couponcode:hover>.coupontooltip { display: block; }

.coupontooltip { border: 0.8ch double #888; background: white; display: none;
	font: 100% monospace; font-size: 1rem; font-weight: normal; /* unset summary settings */
	margin-left: -20ch; padding: 10px; position: absolute; z-index: 1000; }

#navMenu { margin: 0 20px; max-width: 15rem; position: absolute; }

#DMTdragParent {

	width: 150px;
	height: 150px;
	margin: auto;
	background-color: rgb(245, 230, 99);
	border: 10px solid rgba(136, 136, 136, .5);
	overflow: hidden;
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	z-index:5;
	resize: both;
}

#DMTdragItem {

	background-color: blue;
	color: white;
	touch-action: none;
	user-select: none;
	padding: 1ch;
	height: 4ch;
}

#DMTdragParent:active { background-color: rgba(168, 218, 220, 1.00); }

#DMTdragParent:hover { cursor: pointer; border-width: 20px; }

#DMTdragContent {
	height: calc( 100px - 3ch ); position: relative; width: 100%;
}
</style>

</head>

<body>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r114/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r114/examples/js/controls/TrackballControls.js"></script>


<script src="dmt-div-move-touch.js"></script>


<nav id="navMenu">

	<header id="hdrTitle">

		<h2>
			<a id=aSource target=_top title="Source code on GitHub" >
				<img id=imgIcon height=18 style=opacity:0.5; >
			</a>

			<a href="" title="Click to reload this page" >
				<span id=sTitle ></span>
				<span id=sVersion ></span>
			</a>

			<span class="couponcode" >??<span id=divDescription class="coupontooltip" ></span></span>

		</h2>

	</header>

	<p>
		<button onclick="addMeshes()">add meshes</button>
	</p>


	<p>
		<button onclick=controls.reset() >reset view</button>
		<button onclick="sceneRotation = sceneRotation === 1 ? 0 : 1;">rotation</button>
	</p>

	<p>
		<output id=outSpeed>50</output>
		<input type="range" id="inpSpeed" onclick="sceneRotation=0.05 * this.value;outSpeed.innerHTML=this.value;" />
	</p>

	<div id="divLog"></div>
</nav>

<div id="DMTdragParent" >
	<div id="DMTdragItem" >header</div>
	<div id="DMTdragContent" ></div>
</div>




<script>


aSource.href = "https://github.com/zzzzz/xxxxx.html";
imgIcon.src = "https://pushme-pullyou.github.io/github-mark-32.png";

sTitle.innerHTML= document.title ? document.title : location.href.split( '/' ).pop().slice( 0, - 5 ).replace( /-/g, ' ' );
const version = document.head.querySelector( "[ name=version ]" );
sVersion.innerHTML = version ? version.content : "";
divDescription.innerHTML = document.head.querySelector( "[ name=description ]" ).content;


let mesh, group, axesHelper, lightDirectional, cameraHelper;
let sceneRotation = 1;
let renderer, camera, controls, scene;

init();
animate();



function init() {

	camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.set( - 100, - 100, 100 );
	camera.up.set( 0, 0, 1 );

	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0xcce0ff );
	//scene.fog = new THREE.Fog( 0xcce0ff, 550, 800 );
	scene.add( camera )

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	renderer.outputEncoding = THREE.sRGBEncoding;
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;

	controls = new THREE.TrackballControls( camera, renderer.domElement );
	controls.maxDistance = 500;
	controls.rotateSpeed = 2;
	//controls.maxPolarAngle = Math.PI * 0.5;


	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'orientationchange', onWindowResize, false );
	window.addEventListener( 'keyup', () => sceneRotation = 0, false );
	renderer.domElement.addEventListener( 'click', () => sceneRotation = 0, false );

	addLights();

	axesHelper = new THREE.AxesHelper( 100 );
	scene.add( axesHelper );

	addGround();

	//addMesh();

	addMeshes();

	zoomObjectBoundingSphere();

	DMT.init();


	DMTdragContent.innerHTML = "lorem ipsum, quia dolor sit, amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt, ut labore et dolore magnam aliquam quaerat voluptatem. ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? quis autem vel eum iure reprehenderit, qui in ea voluptate velit esse, quam nihil molestiae consequatur, vel illum, qui dolorem eum fugiat, quo voluptas nulla pariatur?";
}


//////////


function addLights() {

	//scene.add( new THREE.AmbientLight( 0x404040 ) );
	scene.add( new THREE.AmbientLight( 0x666666 ) );

	const pointLight = new THREE.PointLight( 0xffffff, 0.2 );
	pointLight.position.copy( camera.position );
	camera.add( pointLight );

	lightDirectional = new THREE.DirectionalLight( 0xdffffff, 0.5 );
	lightDirectional.position.set( -50, -200, 100 );
	lightDirectional.castShadow = true;
	lightDirectional.shadow.mapSize.width = 1024;
	lightDirectional.shadow.mapSize.height = 1024;

	var d = 100;
	lightDirectional.shadow.camera.left = - d;
	lightDirectional.shadow.camera.right = d;
	lightDirectional.shadow.camera.top = d;
	lightDirectional.shadow.camera.bottom = - d;
	lightDirectional.shadow.camera.far = 500;
	scene.add( lightDirectional );

	scene.add( new THREE.CameraHelper( lightDirectional.shadow.camera ) );

}



function addGround() {

	const geometry = new THREE.PlaneBufferGeometry( 2000, 2000 );
	const material = new THREE.MeshPhongMaterial( { color: 0xaaaaaa, depthWrite: false, side: 2 } );
	const mesh = new THREE.Mesh( geometry, material );
	mesh.position.z = -50;
	mesh.receiveShadow = true;
	scene.add( mesh );

}



function zoomObjectBoundingSphere( obj = group ) {
	//console.log( "obj", obj );

	center = new THREE.Vector3( 0, 0, 0 );
	radius=  50;

	const bbox = new THREE.Box3().setFromObject( obj );
	//console.log( 'bbox', bbox );

	if ( bbox.max.x !== Infinity ) {

		const sphere = bbox.getBoundingSphere( new THREE.Sphere() );

		center = sphere.center;
		radius = sphere.radius;
		//console.log( "sphere", sphere )
	}

	controls.target.copy( center ); // needed because model may be far from origin
	controls.maxDistance = 50 * radius;

	delta = camera.position.clone().sub( controls.target ).normalize();
	//console.log( 'delta', delta );

	position = controls.target.clone().add( delta.multiplyScalar( 2 * radius ) );
	//console.log( 'position', position );

	distance = controls.target.distanceTo( camera.position );

	//camera.zoom = distance / (  * radius ) ;

	camera.position.copy( center.clone().add( new THREE.Vector3( -2 * radius, 2 * radius, 1.0 * radius ) ) );
	camera.near = 0.001 * radius; //2 * camera.position.length();
	camera.far = 50 * radius; //2 * camera.position.length();
	camera.updateProjectionMatrix();

	axesHelper.position.copy( center );

	if ( lightDirectional ) {

		lightDirectional.position.copy( center.clone().add( new THREE.Vector3( -1.5 * radius, 1.5 * radius, 1.5 * radius ) ) );
		lightDirectional.shadow.camera.scale.set( 0.02 * radius, 0.02 * radius, 0.2 * radius );

		//targetObject.position.copy( center );

		scene.remove( cameraHelper );
		cameraHelper = new THREE.CameraHelper( lightDirectional.shadow.camera );
		scene.add( cameraHelper );

	}

	let event = new Event( "onresetthree", {"bubbles": true, "cancelable": false, detail: true } );

	//window.addEventListener( "onrresetthree", doThings, false );

	// listening: or-object-rotation-xx.js
	// listening: dss-display-scene-settings-xx.js

	window.dispatchEvent( event );

};



function addMesh( size = 20 ) {

	// CylinderGeometry( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded )
	// SphereGeometry( radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength )
	// TorusGeometry( radius, tube, radialSegments, tubularSegments, arc )

	const geometry = new THREE.BoxGeometry( size, size, size );

	geometry.applyMatrix4( new THREE.Matrix4().makeRotationX( -0.5 * Math.PI ) );
	geometry.applyMatrix4( new THREE.Matrix4().makeScale( 1, 1, 1 ) );
	geometry.applyMatrix4( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	//const material = new THREE.MeshNormalMaterial();
	const material = new THREE.MeshPhongMaterial( { color: 0xffffff * Math.random(), specular: 0xffffff } );
	mesh = new THREE.Mesh( geometry, material );
	mesh.receiveShadow = true;
	mesh.castShadow = true;
	scene.add( mesh );

	return mesh;

}



function addMeshes( count = 100 ) {

	scene.remove( group );

	group = new THREE.Group();

	for ( let i = 0; i < count; i++ ) { group.add( addMesh() ) };

	group.children.forEach( mesh => {
		mesh.position.set( Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50 )
		mesh.rotation.set( 0.2 * Math.random(), 0.2 * Math.random(), 0.2 * Math.random() )
	} );

	scene.add( group );

	zoomObjectBoundingSphere( group )

}



function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

	controls.handleResize();

	//console.log( 'onWindowResize  window.innerWidth', window.innerWidth );

}



function animate() {

	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	controls.update();
	group.rotation.z += sceneRotation / 1000;

}

</script>
</body>
</html>